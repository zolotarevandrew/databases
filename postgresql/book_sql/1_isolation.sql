create table account
(
id integer primary key generated by default as identity,
client text,
amount numeric
);

insert into account
values
(1, 'alice', 1000.00),
(2, 'bob', 100.00),
(3, 'bob3', 900.00);

-- no dirty read

--начинаем две транзакции не фиксируем первую
update accounts set amount = amount - 300 where id = 1;
select * from accounts where client = 'alice';
-- 1 alice 800.000

--начинаем вторую
select * from accounts where client = 'alice';
-- 1 alice 1000.00

-- пусть теперь первая транзация зафикисирует изменения, а вторая повторно выполнит тот же самый запрос.
COMMIT;
select * from accounts where client = 'alice';
-- 1 alice 800.00
-- Запрос получает уже новые данные и это есть аномалия non repeatable read.

-- В транзакции нельзя принимать решения на основании данных прочитанных предыдущим оператором,
-- за время выполнения все может измениться.


IF (Select amount from accounts where id = 1) >= 1000 then
  update accounts set amount = amount - 1000 where id = 1;
END IF

--За время которое проходит между проверкой и обновлением другие транзакции могут изменить состояние счета

--Удобно представить что перед выполнением могут вклинится другие транзакции
IF (Select amount from accounts where id = 1) >= 1000 then
  -- update accounts set amount = amount - 200 where id = 1;
  -- commit;
  update accounts set amount = amount - 1000 where id = 1;
END IF

-- Если переставив операторы можно все испортить значит код написан некорректно.
-- Как написать код корректно

-- Заменить процедурный код декларативным. 
ALTER TABLE accounts ADD CHECK amount >= 0;

-- Использовать один оператор sql, INSERT ON CONFLICT

--Задействовать пользовательские блокировки
SELECT FOR UPDATE или LOCK TABLE`




--non repeatable read

--первая транзакция начала перевод средств с одного счета боба на другой

--1
BEGIN
UPDATE accounts set amount = amount - 100 where id = 2;

--2
BEGIN
SELECT amount from accounts where id = 2;
--100

--другая подсчитывает баланс боба причем подсчет выполняется в цикле по всем счетам.
-- в этот момент первая транзация успешно завершается

-- 1
UPDATE accounts SET amount = amount + 100 where id = 3;
COMMIT;

--2
--другая читает состояние второго счета и видит уже новое значение.
SELECT amount from accounts where id = 3;
--1000

--В итоге вторая транзакция получила в сумме 1100 
-- то есть прочитала не корректные данные. Read skew - несогласованное чтение.

-- Избежать- используя один оператор
select sum(amount) from accounts where client = 'bob';

--если запрос выполняется долго может ли он увидеть часть данных в одном состоянии а часть уже в другом.
select amount, pg_sleep(2)
from accounts where client = 'bob'

--в другой транзакции переводим средства обратно
BEGIN
update accounts set amount = amount + 100 where id = 2;
update accounts where amount = amount - 100 where id = 3;
COMMIT

-- 0
-- 1000
-- показывает данные которые были до начала выполнения - что корректно.



--если в запросе выполняется изменчивая функция VOLATILE и в этой функции выполняется другой запрос
-- то этот вложенный запрос будет видеть данные не согласованные с данными основного запроса

-- это возможно на уровне READ committed и volatile.




-- несогласованное чтение можно получить и при обновлении.

select * from accounts where client = 'bob';
-- 2 bob 200
-- 3 bob 800

--начинаем транзакцию которая уменьшает баланс боба
BEGIN
update accounts set amount = amount - 100 where id = 3;

-- в то же время другая транзакция начисляет проценты на все счета с общим балансом

UPDATE accounts
set amount = amount * 1.01
where client in 
( select client from accounts group by client having sum(amount) >= 1000)

-- выполнение оператора update состоит из двух частей
-- сначала фактически выполняется select а поскольку изменение первой транзакции не зафиксированно
-- вторая не может его видеть и оно никак не повлияет на выбор строк начисления процентов.
-- таким образом счета боба попадают под условие и ему начисляются проценты.

-- на втором этапе выполнения выбранные строки обновляются одна за другой
-- вторая транзакция вынуждена подождать поскольку строка id = 3 изменяется первой транзакцией и поэтому заблокирована.


COMMIT
select * from accounts where client = 'bob';
-- 2 bob 202
-- 3 bob 707

-- После снятие блокировки оператор Update перечитывает строку, которую пытается обновить
-- но только ее одну! в результате получается что бобу начислено 9 исходя из суммы 900
-- Но если бы у боба было 900 его счета не должны были попасть в выборку

-- транзакция прочитала некорректные данные часть строк на один момент времени, часть на другой.
-- Взамен потерянного обновления получаем аномалию несогласованного чтения.